<?xml version="1.0" encoding="utf-8"?>
<topic id="6d517cb6-206e-418e-9b62-956faed83f09" revisionNumber="1">
  <developerReferenceWithSyntaxDocument xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink">

    <introduction>
      <!-- <autoOutline /> -->
      <para>
      	Now that we have set up our data, it is time to create our first algorithm.
      	This example will demonstrate the following techniques:
      </para>
      	<list class="bullet">
      		<listItem>Basic algorithm structure</listItem>
      		<listItem>Loading data</listItem>
      		<listItem>Processing bars and accessing instruments</listItem>
      		<listItem>Accessing time series data</listItem>
      		<listItem>Plotting data</listItem>
      	</list>
    </introduction>

    <section address="Section1">
      <title>Basic algorithm structure</title>
      <content>
        <!-- Uncomment this to create a sub-section outline
        <autoOutline/> -->
        <para>
			The most simple TuringTrader algorithm we can possibly write looks
			like this:
        </para>
		<codeReference>Demo01#DummyClass</codeReference>
		<para>
			First, we add the 
			<codeEntityReference qualifyHint="false">N:TuringTrader.Simulator</codeEntityReference>
			namespace, so that we may
			access the TuringTrader classes without having to qualify
			the use of those types.
		</para>
		<para>
			Next, we derive a public class from TuringTrader's
			<codeEntityReference qualifyHint="false">T:TuringTrader.Simulator.Algorithm</codeEntityReference>
			class.
			This is required, so that the simulator can discover the available
			algorithms using reflection.
		</para>
		<para>
			We override the 
			<codeEntityReference qualifyHint="false" autoUpgrade="true">M:TuringTrader.Simulator.Algorithm.Run</codeEntityReference>
			method. This is where all of the algorithm's
			initialization, data-processing, and cleanup will be performed.
			It is up to you, to group functionality into separate private
			methods as you see fit.
		</para>
		<para>
			We override the
			<codeEntityReference qualifyHint="false" autoUpgrade="true">M:TuringTrader.Simulator.Algorithm.Report</codeEntityReference>
			method. This is where a report is created,
			to present the algorithm's outcome. TuringTrader's preferred way
			of presentation is through Excel worksbooks, but you are free to
			create any report format you see fit.
		</para>
      </content>
    </section>

    <section address="Section2">
      <title>Loading data</title>
      <content>
      	<para>
      		Now that we have a dummy algorithm, it is time to add some useful
      		functionality to the
      		<codeEntityReference qualifyHint="false" autoUpgrade="true">M:TuringTrader.Simulator.Algorithm.Run</codeEntityReference>
      		method.
      		The first thing an algorithm needs to do, is to
      		load data. There are two aspects to this:
      	</para>
  		<list class="bullet">
  			<listItem>Specify the simulation range. We do so, by setting
  				the 
  				<codeEntityReference qualifyHint="false">F:TuringTrader.Simulator.SimulatorCore.StartTime</codeEntityReference>
  				and 
  				<codeEntityReference qualifyHint="false">F:TuringTrader.Simulator.SimulatorCore.EndTime</codeEntityReference>
  				properties.</listItem>
  			<listItem>Add one or more data sources to our algorithm. We
  				do so, by adding 
  				<codeEntityReference qualifyHint="false">T:TuringTrader.Simulator.DataSource</codeEntityReference>
  				objects
  				to the 
  				<codeEntityReference qualifyHint="false">F:TuringTrader.Simulator.SimulatorCore.DataSources</codeEntityReference>
  				property. These objects should be created using the 
  				<codeInline>New</codeInline> 
  				method, which will determine the appropriate data source
  				implementation to load the data.
  				</listItem>
  		</list>
      	<para>
      		The relevant portion of code looks like this:
      	</para>
      	<codeReference>Demo01#LoadData</codeReference>
	  </content>
	</section>

    <section address="Section3">
      <title>Processing bars and accessing instruments</title>
      <content>
      	<para>
      		After we have set our simulation range and added our data sources,
      		we are ready to start processing data. TuringTrader creates a single 
      		event for each bar with the same time stamp. This greatly simplifies
      		the development of algorithms working on instrument portfolios, or 
      		with options. Each bar is requested through the enumerable property 
      		<codeEntityReference qualifyHint="false">P:TuringTrader.Simulator.SimulatorCore.SimTimes</codeEntityReference>
      		with a simple loop:
      	</para>
      	<codeReference>Demo01#ProcessBars</codeReference>
      	<para>
      		Inside this loop, we can access the
      		<codeEntityReference qualifyHint="false">P:TuringTrader.Simulator.SimulatorCore.Instruments</codeEntityReference>
      		property, which
      		holds all known instruments. There are a number of ways to find the
      		instrument object we are looking for. For a simple algorithm,
      		working on only a single instrument, e.g. a basic stock-trading
      		algorithm, we can simply use the first element:
      	</para>
      	<codeReference>Demo01#FirstInstrument</codeReference>
		<para>
			For more complex algorithms referencing multiple instruments, we
			can look up the instrument via its nickname using
			<codeEntityReference qualifyHint="false" autoUpgrade="true">M:TuringTrader.Simulator.SimulatorCore.FindInstrument(System.String)</codeEntityReference>.
			Please note that this
			won’t work, if there is a one-to-many relationship between our
			nickname and the resulting instruments:
		</para>
		<codeReference>Demo01#FindInstrument</codeReference>
		<para>
			If there is a one-to-many relationship between our nickname and the 
			resulting instruments, we are probably dealing with options. We’ll 
			talk about that when we walk through the options trading demo.
		</para>
		<para>
			An
			<codeEntityReference qualifyHint="false">T:TuringTrader.Simulator.Instrument</codeEntityReference>
			holds, among others, the following invariable information:
		</para>
		<list class="bullet">
			<listItem>Nickname. The nickname we used to add the data source</listItem>
			<listItem>Name. The descriptive name of the instrument. E.g. "Alphabet Inc Class A".</listItem>
			<listItem>Symbol. The full symbol used to trade this instrument. 
				This may be the ticker, as in "GOOGL", or the ticker plus 
				expiry, right, and strike as in "XSP180919P00284000".</listItem>
			<listItem>LastTime. This is the timestamp of the last bar 
				received by this instrument. This is important to
				distinguish active from stale instruments.</listItem>
		</list>
	  </content>
	</section>

    <section address="Section4">
      <title>Accessing time series data</title>
      <content>
      	<para>
      		An 
      		<codeEntityReference qualifyHint="false">T:TuringTrader.Simulator.Instrument</codeEntityReference>
      		also holds, among others, the following time series:
      	</para>
  		<list class="bullet">
  			<listItem>Open, High, Low, Close, Volume: The market quote data.</listItem>
  			<listItem>Bid, Ask, BidVolume, AskVolume: The bid/ask quote data.</listItem>
  		</list>
      	<para>
      		We can access time series data much like array elements, via the 
      		<codeEntityReference qualifyHint="false">T:TuringTrader.Simulator.ITimeSeries`1</codeEntityReference>
      		interface.
      		The index 0 points to
      		the most current data, index 1 points to the data from the previous
      		bar, and so forth. Typically, we can access up to 256 bars in the past:
      	</para>
      	<codeReference>Demo01#TimeSeries</codeReference>
      	<para>
      		Indicators can be calculated on any time series data. The result of
      		an indicator is typically also a time series:
      	</para>
      	<codeReference>Demo01#Indicators</codeReference>
		<para>
			With the output of indicators being time series, we can calculate
			indicators on indicators. The following code details the calculation
			of
			<codeEntityReference qualifyHint="false" autoUpgrade="true">M:TuringTrader.Simulator.IndicatorsTrend.MACD(TuringTrader.Simulator.ITimeSeries{System.Double},System.Int32,System.Int32,System.Int32)</codeEntityReference>
			step by step:
		</para>
		<codeReference>Demo01#MACD</codeReference>
	  </content>
	</section>

    <section address="Section5">
      <title>Plotting data</title>
      <content>
      	<para>
      		Our algorithm now calculates MACD, but it won't share the
      		results with us. TuringTrader can easily save data to a CSV,
      		or plot in Excel and
      		R. To do so, we first need to create a 
      		<codeEntityReference qualifyHint="false">T:TuringTrader.Simulator.Plotter</codeEntityReference>
      		object:
      	</para>
      	<codeReference>Demo01#NewLogger</codeReference>
      	<para>
      		A
      		<codeEntityReference qualifyHint="false">T:TuringTrader.Simulator.Plotter</codeEntityReference>
      		object can hold multiple plots. Before we add data to a plot,
      		we need to selec a working plot, and specify the name of the horizontal
      		axis with
      		<codeEntityReference qualifyHint="false" autoUpgrade="true">M:TuringTrader.Simulator.Plotter.SelectPlot(System.String,System.String)</codeEntityReference>
      		:
      	</para>
      	<codeReference>Demo01#SelectPlot</codeReference>
      	<para>
      		Now, for every bar we process, we need to set the value on the
      		horizontal axis with
      		<codeEntityReference qualifyHint="false" autoUpgrade="true">M:TuringTrader.Simulator.Plotter.SetX(System.Object)</codeEntityReference>
      		:
      	</para>
      	<codeReference>Demo01#SetX</codeReference>
      	<para>
      		Once we have done so, we can add one or more values to the
      		vertical axis with
      		<codeEntityReference qualifyHint="false" autoUpgrade="true">M:TuringTrader.Simulator.Plotter.Plot(System.String,System.Object)</codeEntityReference>
      		:
      	</para>
      	<codeReference>Demo01#Log</codeReference>
      	<para>
      		At the end of the simulation, we can create a CSV file with a simple call to
      		<codeEntityReference qualifyHint="false" autoUpgrade="true">M:TuringTrader.Simulator.Plotter.SaveAsCsv(System.String,System.String,System.Func{System.Object,System.String})</codeEntityReference>
      		:
      	</para>
      	<codeReference>Demo01#SaveAsCsv</codeReference>
      	<para>
      		This will create a CSV file at the specified location like this:
      	</para>
      	<codeReference>Demo01#csv</codeReference>
      	<para>
      		It is worth noting, that all output functionality should generally
      		be implemented in the 
      		<codeEntityReference qualifyHint="false" autoUpgrade="true">M:TuringTrader.Simulator.Algorithm.Report</codeEntityReference>
      		method. That way, no unnecessary
      		output is getting into our way, especially while running the
      		optimizer.
      	</para>
      	<para>
      		Typically, a graphical representation of our data is more appealing.
      		Creating an pretty plot requires just a simple call to
      		<codeEntityReference qualifyHint="false" autoUpgrade="true">M:TuringTrader.Simulator.Plotter.OpenWith(System.String)</codeEntityReference>
      		:
      	</para>
      	<codeReference>Demo01#OpenWithExcel</codeReference>
      	<para>
      		The parameter passed into the method points to a template, which
      		controls the appearance. There are virtually no 
      		limits to the customized reports and plots that can be created. 
      		The repository contains simple templates, but you are welcome to 
      		create your own.
  		</para>
  		<para>
      		If you are plotting with Excel, the template you need is an Excel
      		worksheet containing a VBA macro. If you are plotting to R, the
      		required template is either a straight R script, or an RMarkdown
      		script. Here is how a simple Excel plot will look like:
      	</para>
      	<mediaLink>
		<!-- <caption>Demo 01-plot-small</caption> -->
		<image xlink:href="Demo01-plot-small"/>
		</mediaLink>
	  </content>
	</section>

    <relatedTopics>
    </relatedTopics>
  </developerReferenceWithSyntaxDocument>
</topic>