<?xml version="1.0" encoding="utf-8"?>
<topic id="6d517cb6-206e-418e-9b62-956faed83f09" revisionNumber="1">
  <developerReferenceWithSyntaxDocument xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink">

    <introduction>
      <!-- <autoOutline /> -->
      <para>
      	Now that we have set up our data, it is time to create our first algorithm.
      	This example will demonstrate the following techniques:
      	<list class="bullet">
      		<listItem>Basic algorithm structure</listItem>
      		<listItem>Loading data</listItem>
      		<listItem>Processing bars and accessing instruments</listItem>
      		<listItem>Accessing time series data</listItem>
      		<listItem>Plotting data</listItem>
      	</list>
      </para>
    </introduction>

    <section address="Section1">
      <title>Basic algorithm structure</title>
      <content>
        <!-- Uncomment this to create a sub-section outline
        <autoOutline/> -->
        <para>
			The most simple TuringTrader algorithm we can possibly write looks
			like this:
        </para>
		<codeReference>Demo01#DummyClass</codeReference>
		<para>
			First, we add the <codeInline>TuringTrader.Simulator</codeInline> namespace, so that we may
			access the TuringTrader classes without having to qualify
			the use of those types.
		</para>
		<para>
			Next, we derive a public class from TuringTrader's <codeInline>Algorithm</codeInline> class.
			This is required, so that the simulator can discover the available
			algorithms using reflection.
		</para>
		<para>
			We override the <codeInline>Run()</codeInline> method. This is where all of the algorithm's
			initialization, data-processing, and cleanup will be performed.
			It is up to you, to group functionality into separate private
			methods as you see fit.
		</para>
		<para>
			We override the <codeInline>Report()</codeInline> method. This is where a report is created,
			to present the algorithm's outcome. TuringTrader's preferred way
			of presentation is through Excel worksbooks, but you are free to
			create any report format you see fit.
		</para>
      </content>
    </section>

    <section address="Section2">
      <title>Loading data</title>
      <content>
      	<para>
      		Now that we have a dummy algorithm, it is time to add some useful
      		functionality to the <codeInline>Run()</codeInline> method.
      		The first thing an algorithm needs to do, is to
      		load data. There are two aspects to this:
      		<list class="bullet">
      			<listItem>Specify the simulation range. We do so, by setting
      				the <codeInline>StartTime</codeInline> and <codeInline>EndTime</codeInline> properties.</listItem>
      			<listItem>Add one or more data sources to our algorithm. We
      				do so, by adding <codeInline>DataSource</codeInline> objects 
      				to the <codeInline>DataSources</codeInline>
      				property.</listItem>
      		</list>
      	</para>
      	<para>
      		The relevant portion of code looks like this:
      	</para>
      	<codeReference>Demo01#LoadData</codeReference>
	  </content>
	</section>

    <section address="Section3">
      <title>Processing bars and accessing instruments</title>
      <content>
      	<para>
      		After we have set our simulation range and added our data sources,
      		we are ready to start processing data. TuringTrader creates a single 
      		event for each bar with the same time stamp. This greatly simplifies
      		the development of algorithms working on instrument portfolios, or 
      		with options. Each bar is requested through the enumerable property 
      		<codeInline>SimTimes</codeInline> with a simple loop:
      	</para>
      	<codeReference>Demo01#ProcessBars</codeReference>
      	<para>
      		Inside this loop, we can access the <codeInline>Instruments</codeInline> dictionary, which 
      		holds all known instruments. There are a number of ways to find the
      		instrument object we are looking for. For a simple algorithm,
      		working on only a single instrument, e.g. a basic stock-trading
      		algorithm, we can simply use the first element of the <codeInline>Instruments</codeInline>
      		dictionary:
      	</para>
      	<codeReference>Demo01#FirstInstrument</codeReference>
		<para>
			For more complex algorithms referencing multiple instruments, we
			can look up the instrument via its nickname. Please note that this
			won’t work, if there is a one-to-many relationship between our
			nickname and the resulting instruments:
		</para>
		<codeReference>Demo01#FindInstrument</codeReference>
		<para>
			If there is a one-to-many relationship between our nickname and the 
			resulting instruments, we are probably dealing with options. We’ll 
			talk about that when we walk through the options trading demo.
		</para>
		<para>
			An instrument holds, among others, the following static fields:
			<list class="bullet">
				<listItem>Nickname. The nickname we used to add the data source</listItem>
				<listItem>Name. The descriptive name of the instrument. E.g. "Alphabet Inc Class A".</listItem>
				<listItem>Symbol. The full symbol used to trade this instrument. 
					This may be the ticker, as in "GOOGL", or the ticker plus 
					expiry, right, and strike as in "XSP180919P00284000".</listItem>
				<listItem>LastTime. This is the timestamp of the last bar 
					received by this instrument. This is important to
					distinguish active from stale instruments.</listItem>
			</list>
		</para>
	  </content>
	</section>

    <section address="Section4">
      <title>Accessing time series data</title>
      <content>
      	<para>
      		An instrument also holds, among others, the following time series:
      		<list class="bullet">
      			<listItem>Open, High, Low, Close, Volume: The market quote data.</listItem>
      			<listItem>Bid, Ask, BidVolume, AskVolume: The bid/ask quote data.</listItem>
      		</list>
      	</para>
      	<para>
      		We can access time series data much like array elements, via the 
      		<codeInline>ITimeSeries</codeInline> interface.
      		The index 0 points to
      		the most current data, index 1 points to the data from the previous
      		bar, and so forth. Typically, we can access up to 256 bars in the past:
      	</para>
      	<codeReference>Demo01#TimeSeries</codeReference>
      	<para>
      		Indicators can be calculated on any time series data. The result of
      		an indicator is typically also a time series:
      	</para>
      	<codeReference>Demo01#Indicators</codeReference>
		<para>
			With the output of indicators being time series, we can calculate
			indicators on indicators. The following code details the calculation
			of MACD step by step:
		</para>
		<codeReference>Demo01#MACD</codeReference>
	  </content>
	</section>

    <section address="Section5">
      <title>Plotting data</title>
      <content>
      	<para>
      		Our algorithm now calculates MACD, but it won't share the
      		results with us. TuringTrader can easily save data to a CSV,
      		or plot in Excel and
      		R. To do so, we first need to create a <codeInline>Logger</codeInline> object:
      	</para>
      	<codeReference>Demo01#NewLogger</codeReference>
      	<para>
      		A <codeInline>Logger</codeInline> object can hold multiple plots. Before we add data to a plot,
      		we need to set a working plot, and specify the name of the horizontal
      		axis:
      	</para>
      	<codeReference>Demo01#SelectPlot</codeReference>
      	<para>
      		Now, for every bar we process, we need to set the value on the
      		horizontal axis:
      	</para>
      	<codeReference>Demo01#SetX</codeReference>
      	<para>
      		Once we have done so, we can add one or more values to the
      		vertical axis:
      	</para>
      	<codeReference>Demo01#Log</codeReference>
      	<para>
      		At the end of the simulation, we can create a CSV file with a single
      		line of code:
      	</para>
      	<codeReference>Demo01#SaveAsCsv</codeReference>
      	<para>
      		This will create a CSV file at the specified location like this:
      	</para>
      	<codeReference>Demo01#csv</codeReference>
      	<para>
      		It is worth noting, that all output functionality should generally
      		be implemented in the <codeInline>Report()</codeInline> method. That way, no unnecessary
      		output is getting into our way, especially while running the
      		optimizer.
      	</para>
      	<para>
      		Typically, a graphical representation of our data is more appealing.
      		Creating an Excel plot can also done with just a single line of code:
      	</para>
      	<codeReference>Demo01#OpenWithExcel</codeReference>
      	<para>
      		The parameter passed into the <codeInline>OpenWithExcel()</codeInline> function points to an
      		Excel template. These templates include a VBA macro, that will
      		receive the CSV, and create the desired output. 
			By modifying the templates, there are virtually no limits to
      		the customized plots and reports that can be created.
      		The project includes
      		a simple template, which will create plots like this:
      	</para>
      	<mediaLink>
		<!-- <caption>Demo 01-plot-small</caption> -->
		<image xlink:href="Demo01-plot-small"/>
		</mediaLink>
	  </content>
	</section>

    <relatedTopics>
    </relatedTopics>
  </developerReferenceWithSyntaxDocument>
</topic>