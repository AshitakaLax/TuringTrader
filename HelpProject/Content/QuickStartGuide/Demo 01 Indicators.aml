<?xml version="1.0" encoding="utf-8"?>
<topic id="6d517cb6-206e-418e-9b62-956faed83f09" revisionNumber="1">
<developerReferenceWithSyntaxDocument xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink">

<introduction>
<!-- <autoOutline /> -->

<para>
It is time to start coding and create our first algorithm. In this example, 
we demonstrate the following techniques:
</para>

<list class="bullet">
<listItem>Basic algorithm structure</listItem>
<listItem>Loading data</listItem>
<listItem>Processing bars and accessing instruments</listItem>
<listItem>Accessing time series data</listItem>
<listItem>Plotting data</listItem>
</list>

</introduction>

<section address="Section1"><title>Basic Algorithm Structure</title><content>
<!-- Uncomment this to create a sub-section outline
<autoOutline/> -->

<para>
The most simple TuringTrader algorithm we can write looks like this: 
</para>

<codeReference>Demo01#DummyClass</codeReference>

<para>
First, we add the 
<codeEntityReference qualifyHint="false">N:TuringTrader.Simulator</codeEntityReference>
namespace, so that we may access TuringTrader's classes without having to 
qualify the use of those types. 
</para>

<para>
Next, we derive a new class from TuringTrader's
<codeEntityReference qualifyHint="false">T:TuringTrader.Simulator.Algorithm</codeEntityReference>
class. We make our new class public so that the simulator can discover the 
available algorithms using reflection. 
</para>

<para>
The
<codeEntityReference qualifyHint="false" autoUpgrade="true">M:TuringTrader.Simulator.Algorithm.Run</codeEntityReference>
method is where we implement all of the algorithm's logic: initialization, 
data-processing, and cleanup. The simulator calls Run only once over the 
lifetime of an algorithm object.
</para>

<para>
The
<codeEntityReference qualifyHint="false" autoUpgrade="true">M:TuringTrader.Simulator.Algorithm.Report</codeEntityReference>
method. method is where we render a report to present the algorithm's outcome. 
TuringTrader can create reports in many different ways, based on user-definable 
templates, allowing you to create any report format you see fit. 
</para>

</content></section>

<section address="Section2"><title>Loading Data</title><content>

<para>
Now that we have a dummy algorithm, it is time to add some useful functionality 
to the
<codeEntityReference qualifyHint="false" autoUpgrade="true">M:TuringTrader.Simulator.Algorithm.Run</codeEntityReference>
method. The first thing an algorithm needs to do is to load data. We do so in 
two steps: 
</para>

<list class="bullet">
<listItem>Specify the simulation range. We do so by setting
the 
<codeEntityReference qualifyHint="false">F:TuringTrader.Simulator.SimulatorCore.StartTime</codeEntityReference>
and 
<codeEntityReference qualifyHint="false">F:TuringTrader.Simulator.SimulatorCore.EndTime</codeEntityReference>
properties.</listItem>
<listItem>Add one or more 
<codeEntityReference qualifyHint="false">T:TuringTrader.Simulator.DataSource</codeEntityReference>
objects objects to our algorithm. We do so by calling 
<codeEntityReference qualifyHint="false" autoUpgrade="true">M:TuringTrader.Simulator.SimulatorCore.AddDataSource(System.String)</codeEntityReference>
, which instantiates the appropriate data source implementation to load the data.
</listItem>
</list>

<para>
The relevant portion of code looks like this:
</para>

<codeReference>Demo01#LoadData</codeReference>

</content></section>

<section address="Section3"><title>Processing Bars and Accessing Instruments</title><content>

<para>
We are now ready to start processing data. TuringTrader creates a single event 
for each simulation time stamp. This model greatly simplifies the development 
of algorithms working on instrument portfolios, or with options. We request 
simulation time stamps by looping through the  
<codeEntityReference qualifyHint="false">P:TuringTrader.Simulator.SimulatorCore.SimTimes</codeEntityReference>
enumerable:
</para>

<codeReference>Demo01#ProcessBars</codeReference>

<para>
Inside this loop, we have access to the
<codeEntityReference qualifyHint="false">P:TuringTrader.Simulator.SimulatorCore.Instruments</codeEntityReference>
property, which holds all known instruments. There are several ways to find the 
instrument object we are looking for. For a simple algorithm, working on only a 
single instrument, e.g., a basic stock-trading algorithm, we can use the first 
element: 
</para>

<codeReference>Demo01#FirstInstrument</codeReference>

<para>
Most algorithms reference multiple instruments. In this case, we can look up the 
instrument via its nickname using
<codeEntityReference qualifyHint="false" autoUpgrade="true">M:TuringTrader.Simulator.SimulatorCore.FindInstrument(System.String)</codeEntityReference>.
As a side-note, this won't work for option strategies, with a one-to-many 
relationship between a nickname and the resulting instruments: 
</para>

<codeReference>Demo01#FindInstrument</codeReference>

<para>
When trading options, there is a one-to-many relationship between a nickname 
and the instrument it references, which requires a slightly different approach. 
We'll talk about that when we walk through the options trading demo. 
</para>

<para>
An
<codeEntityReference qualifyHint="false">T:TuringTrader.Simulator.Instrument</codeEntityReference>
holds, among others, the following invariable information:
</para>

<list class="bullet">
<listItem>Nickname: the nickname we used to add the data source.</listItem>
<listItem>Name: the descriptive name of the instrument, e.g., "Alphabet Inc 
Class A".</listItem>
<listItem>Symbol: the full symbol used to trade this instrument: this may be the 
ticker, as in "GOOGL", or the ticker plus expiry, right, and strike as in 
"XSP180919P00284000".</listItem>
<listItem>LastTime: this is the timestamp of the last bar received by this 
instrument, which is essential to distinguish active from stale instruments.</listItem>
</list>

</content></section><section address="Section4"><title>Accessing Time Series Data</title><content>

<para>
An 
<codeEntityReference qualifyHint="false">T:TuringTrader.Simulator.Instrument</codeEntityReference>
also holds, among others, the following time series: 
</para>

<list class="bullet">
<listItem>Open, High, Low, Close, Volume: the market quote data.</listItem>
<listItem>Bid, Ask, BidVolume, AskVolume: the bid/ask quote data.</listItem>
</list>

<para>
We can access time series data much like array elements, via the 
<codeEntityReference qualifyHint="false">T:TuringTrader.Simulator.ITimeSeries`1</codeEntityReference>
interface. The index 0 points to the most current data, index 1 points to the 
data from the previous bar, and so forth. Typically, we have access to up to 
256 bars in the past: 
</para>

<codeReference>Demo01#TimeSeries</codeReference>

<para>
Indicators are calculated on time series data. The result of an indicator is 
typically also a time series:
</para>

<codeReference>Demo01#Indicators</codeReference>

<para>
With the output of indicators being time series, we can calculate indicators on 
indicators. The following code details the calculation of 
<codeEntityReference qualifyHint="false" autoUpgrade="true">M:TuringTrader.Simulator.IndicatorsTrend.MACD(TuringTrader.Simulator.ITimeSeries{System.Double},System.Int32,System.Int32,System.Int32)</codeEntityReference>
step by step:
</para>

<codeReference>Demo01#MACD</codeReference>

<para>
TuringTrader includes many 'industry standard' indicators, all of which residing 
in the 
<codeEntityReference qualifyHint="false">N:TuringTrader.Indicators</codeEntityReference>
namespace.
</para>

</content></section>

<section address="Section5"><title>Plotting Data</title><content>

<para>
Our algorithm now calculates MACD, but it won't share the results with us. 
TuringTrader can render data natively, save them as CSV, or pass them on to 
Excel and R. In all cases, we first need to create a
<codeEntityReference qualifyHint="false">T:TuringTrader.Simulator.Plotter</codeEntityReference>
object:
</para>

<codeReference>Demo01#NewLogger</codeReference>

<para>
A
<codeEntityReference qualifyHint="false">T:TuringTrader.Simulator.Plotter</codeEntityReference>
object can hold multiple charts. Before we add data, we need to select the 
working chart, and specify the name of the horizontal axis with 
<codeEntityReference qualifyHint="false" autoUpgrade="true">M:TuringTrader.Simulator.Plotter.SelectChart(System.String,System.String)</codeEntityReference>
:
</para>

<codeReference>Demo01#SelectPlot</codeReference>

<para>
Now, for every bar we process, we need to set the value along the horizontal 
axis with
<codeEntityReference qualifyHint="false" autoUpgrade="true">M:TuringTrader.Simulator.Plotter.SetX(System.Object)</codeEntityReference>
:
</para>

<codeReference>Demo01#SetX</codeReference>

<para>
Next, we can add one or more values to the vertical axis with
<codeEntityReference qualifyHint="false" autoUpgrade="true">M:TuringTrader.Simulator.Plotter.Plot(System.String,System.Object)</codeEntityReference>
:
</para>

<codeReference>Demo01#Log</codeReference>

<para>
At the end of the simulation, we can create a CSV file with a simple call to
<codeEntityReference qualifyHint="false" autoUpgrade="true">M:TuringTrader.Simulator.Plotter.SaveAsCsv(System.String,System.String,System.Func{System.Object,System.String})</codeEntityReference>
:
</para>

<codeReference>Demo01#SaveAsCsv</codeReference>

<para>
As a result, we create a CSV file at the specified location like this, but with 
many more lines:
</para>

<codeReference>Demo01#csv</codeReference>

<para>
We typically implement all output functionality in 
<codeEntityReference qualifyHint="false" autoUpgrade="true">M:TuringTrader.Simulator.Algorithm.Report</codeEntityReference>
method. That way, no unnecessary output is getting into our way, especially 
while running the optimizer. 
</para>

<para>
We like charts much more than tables. Creating a pretty plot requires just a 
simple call to
<codeEntityReference qualifyHint="false" autoUpgrade="true">M:TuringTrader.Simulator.Plotter.OpenWith(System.String)</codeEntityReference>
:
</para>

<codeReference>Demo01#OpenWithExcel</codeReference>

<para>
The parameter passed into the method points to a template, which controls the 
appearance. If the template file name does not include an extension, like in 
this example, the extension used is the Default Extension from the Report 
Output Settings:
</para>

<mediaLink>
<image xlink:href="output-xlsm"/>
</mediaLink>

<para>
There are virtually no limits to the customized reports and plots we can create. 
The repository contains simple templates, but you are welcome to create your 
own. Read this topic to learn more:
<link xlink:href="ecc0bf75-4bc6-4e29-889b-f6249448f25a" />
</para>

<para>
Please find the full code for this demo in our 
<externalLink>
<linkText>repository</linkText>
<linkUri>https://bitbucket.org/fbertram/fub_tradingsimulator/src/develop/Algorithms/Demo%20Algorithms/Demo01_Indicators.cs</linkUri>
<linkTarget>_blank</linkTarget>
</externalLink> 
. Assuming we have set the default extension to Excel, the resulting chart
will look like this:
</para>

<mediaLink>
<!-- <caption>Demo 01-plot-small</caption> -->
<image xlink:href="Demo01-plot-small"/>
</mediaLink>

</content></section>

<relatedTopics>
</relatedTopics>
</developerReferenceWithSyntaxDocument>
</topic>